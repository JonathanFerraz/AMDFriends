"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signFile = exports.patchFile = void 0;
const child_process_1 = require("child_process");
const util_1 = require("util");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const regexes_1 = __importDefault(require("./regexes"));
const routines_1 = require("./routines");
async function patchFile(filePath, dryRun) {
    const patchedFilePath = path_1.resolve(path_1.dirname(filePath), path_1.basename(filePath, path_1.extname(filePath)) + ".patched" + path_1.extname(filePath));
    let buffer = await promises_1.readFile(filePath, "binary");
    console.log("Searching and replacing for instruction __mkl_intel_serving_cpu_true...");
    buffer = routines_1.replaceAll(buffer, regexes_1.default.__mkl_serv_intel_cpu_true.find, regexes_1.default.__mkl_serv_intel_cpu_true.replace);
    console.log("Searching and replacing for instructions __intel_fast_memset.A and __intel_fast_memcpy.A...");
    buffer = routines_1.replaceAll(buffer, regexes_1.default.__intel_fast_memset_or_memcpy_A.find, regexes_1.default.__intel_fast_memset_or_memcpy_A.replace);
    console.log("Writing resulting file...");
    if (!dryRun)
        await promises_1.writeFile(patchedFilePath, buffer, "binary");
    console.log("Invoking command:", `xattr -cr "${patchedFilePath}"`);
    if (!dryRun)
        await util_1.promisify(child_process_1.exec)(`xattr -cr "${patchedFilePath}"`);
    return patchedFilePath;
}
exports.patchFile = patchFile;
async function signFile(filePath, dryRun) {
    console.log("Invoking command:", `codesign --force --deep --sign - "${filePath}"`);
    if (!dryRun)
        await util_1.promisify(child_process_1.exec)(`codesign --force --deep --sign - "${filePath}"`);
}
exports.signFile = signFile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaURBQXFDO0FBQ3JDLCtCQUFpQztBQUNqQywwQ0FBa0Q7QUFDbEQsK0JBQTJEO0FBQzNELHdEQUFnQztBQUNoQyx5Q0FBd0M7QUFFakMsS0FBSyxVQUFVLFNBQVMsQ0FBQyxRQUFnQixFQUFFLE1BQWU7SUFDaEUsTUFBTSxlQUFlLEdBQUcsY0FBTyxDQUFDLGNBQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxlQUFRLENBQUMsUUFBUSxFQUFFLGNBQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLFVBQVUsR0FBRyxjQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUUzSCxJQUFJLE1BQU0sR0FBRyxNQUFNLG1CQUFRLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRWhELE9BQU8sQ0FBQyxHQUFHLENBQUMseUVBQXlFLENBQUMsQ0FBQztJQUN2RixNQUFNLEdBQUcscUJBQVUsQ0FDbEIsTUFBTSxFQUNOLGlCQUFPLENBQUMseUJBQXlCLENBQUMsSUFBSSxFQUN0QyxpQkFBTyxDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FDekMsQ0FBQztJQUVGLE9BQU8sQ0FBQyxHQUFHLENBQUMsNkZBQTZGLENBQUMsQ0FBQztJQUMzRyxNQUFNLEdBQUcscUJBQVUsQ0FDbEIsTUFBTSxFQUNOLGlCQUFPLENBQUMsK0JBQStCLENBQUMsSUFBSSxFQUM1QyxpQkFBTyxDQUFDLCtCQUErQixDQUFDLE9BQU8sQ0FDL0MsQ0FBQztJQUVGLE9BQU8sQ0FBQyxHQUFHLENBQUMsMkJBQTJCLENBQUMsQ0FBQztJQUN6QyxJQUFHLENBQUMsTUFBTTtRQUNULE1BQU0sb0JBQVMsQ0FBQyxlQUFlLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRXBELE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsY0FBYyxlQUFlLEdBQUcsQ0FBQyxDQUFDO0lBQ25FLElBQUcsQ0FBQyxNQUFNO1FBQ1QsTUFBTSxnQkFBUyxDQUFDLG9CQUFJLENBQUMsQ0FBQyxjQUFjLGVBQWUsR0FBRyxDQUFDLENBQUM7SUFFekQsT0FBTyxlQUFlLENBQUM7QUFDeEIsQ0FBQztBQTVCRCw4QkE0QkM7QUFFTSxLQUFLLFVBQVUsUUFBUSxDQUFDLFFBQWdCLEVBQUUsTUFBZTtJQUMvRCxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLHFDQUFxQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0lBQ25GLElBQUcsQ0FBQyxNQUFNO1FBQ1QsTUFBTSxnQkFBUyxDQUFDLG9CQUFJLENBQUMsQ0FBQyxxQ0FBcUMsUUFBUSxHQUFHLENBQUMsQ0FBQztBQUMxRSxDQUFDO0FBSkQsNEJBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gXCJ1dGlsXCI7XG5pbXBvcnQgeyByZWFkRmlsZSwgd3JpdGVGaWxlIH0gZnJvbSBcImZzL3Byb21pc2VzXCI7XG5pbXBvcnQgeyBiYXNlbmFtZSwgZGlybmFtZSwgZXh0bmFtZSwgcmVzb2x2ZSB9IGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgcmVnZXhlcyBmcm9tIFwiLi9yZWdleGVzXCI7XG5pbXBvcnQgeyByZXBsYWNlQWxsIH0gZnJvbSBcIi4vcm91dGluZXNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhdGNoRmlsZShmaWxlUGF0aDogc3RyaW5nLCBkcnlSdW46IGJvb2xlYW4pOiBQcm9taXNlPHN0cmluZz4ge1xuXHRjb25zdCBwYXRjaGVkRmlsZVBhdGggPSByZXNvbHZlKGRpcm5hbWUoZmlsZVBhdGgpLCBiYXNlbmFtZShmaWxlUGF0aCwgZXh0bmFtZShmaWxlUGF0aCkpICsgXCIucGF0Y2hlZFwiICsgZXh0bmFtZShmaWxlUGF0aCkpO1xuXG5cdGxldCBidWZmZXIgPSBhd2FpdCByZWFkRmlsZShmaWxlUGF0aCwgXCJiaW5hcnlcIik7XG5cblx0Y29uc29sZS5sb2coXCJTZWFyY2hpbmcgYW5kIHJlcGxhY2luZyBmb3IgaW5zdHJ1Y3Rpb24gX19ta2xfaW50ZWxfc2VydmluZ19jcHVfdHJ1ZS4uLlwiKTtcblx0YnVmZmVyID0gcmVwbGFjZUFsbChcblx0XHRidWZmZXIsXG5cdFx0cmVnZXhlcy5fX21rbF9zZXJ2X2ludGVsX2NwdV90cnVlLmZpbmQsXG5cdFx0cmVnZXhlcy5fX21rbF9zZXJ2X2ludGVsX2NwdV90cnVlLnJlcGxhY2Vcblx0KTtcblxuXHRjb25zb2xlLmxvZyhcIlNlYXJjaGluZyBhbmQgcmVwbGFjaW5nIGZvciBpbnN0cnVjdGlvbnMgX19pbnRlbF9mYXN0X21lbXNldC5BIGFuZCBfX2ludGVsX2Zhc3RfbWVtY3B5LkEuLi5cIik7XG5cdGJ1ZmZlciA9IHJlcGxhY2VBbGwoXG5cdFx0YnVmZmVyLFxuXHRcdHJlZ2V4ZXMuX19pbnRlbF9mYXN0X21lbXNldF9vcl9tZW1jcHlfQS5maW5kLFxuXHRcdHJlZ2V4ZXMuX19pbnRlbF9mYXN0X21lbXNldF9vcl9tZW1jcHlfQS5yZXBsYWNlXG5cdCk7XG5cblx0Y29uc29sZS5sb2coXCJXcml0aW5nIHJlc3VsdGluZyBmaWxlLi4uXCIpO1xuXHRpZighZHJ5UnVuKVxuXHRcdGF3YWl0IHdyaXRlRmlsZShwYXRjaGVkRmlsZVBhdGgsIGJ1ZmZlciwgXCJiaW5hcnlcIik7XG5cblx0Y29uc29sZS5sb2coXCJJbnZva2luZyBjb21tYW5kOlwiLCBgeGF0dHIgLWNyIFwiJHtwYXRjaGVkRmlsZVBhdGh9XCJgKTtcblx0aWYoIWRyeVJ1bilcblx0XHRhd2FpdCBwcm9taXNpZnkoZXhlYykoYHhhdHRyIC1jciBcIiR7cGF0Y2hlZEZpbGVQYXRofVwiYCk7XG5cblx0cmV0dXJuIHBhdGNoZWRGaWxlUGF0aDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25GaWxlKGZpbGVQYXRoOiBzdHJpbmcsIGRyeVJ1bjogYm9vbGVhbil7XG5cdGNvbnNvbGUubG9nKFwiSW52b2tpbmcgY29tbWFuZDpcIiwgYGNvZGVzaWduIC0tZm9yY2UgLS1kZWVwIC0tc2lnbiAtIFwiJHtmaWxlUGF0aH1cImApO1xuXHRpZighZHJ5UnVuKVxuXHRcdGF3YWl0IHByb21pc2lmeShleGVjKShgY29kZXNpZ24gLS1mb3JjZSAtLWRlZXAgLS1zaWduIC0gXCIke2ZpbGVQYXRofVwiYCk7XG59XG4iXX0=