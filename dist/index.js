"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signFile = exports.patchFile = void 0;
const child_process_1 = require("child_process");
const util_1 = require("util");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const regexes_1 = __importDefault(require("./regexes"));
const routines_1 = require("./routines");
async function patchFile(filePath) {
    const patchedFilePath = path_1.resolve(path_1.dirname(filePath), path_1.basename(filePath, path_1.extname(filePath)) + ".patched" + path_1.extname(filePath));
    let buffer = await promises_1.readFile(filePath, "binary");
    console.log("Searching and replacing for instruction __mkl_intel_serving_cpu_true...");
    buffer = routines_1.replaceAll(buffer, regexes_1.default.__mkl_serv_intel_cpu_true.find, regexes_1.default.__mkl_serv_intel_cpu_true.replace);
    console.log("Searching and replacing for instructions __intel_fast_memset.A and __intel_fast_memcpy.A...");
    buffer = routines_1.replaceAll(buffer, regexes_1.default.__intel_fast_memset_or_memcpy_A.find, regexes_1.default.__intel_fast_memset_or_memcpy_A.replace);
    console.log("Writing resulting file...");
    await promises_1.writeFile(patchedFilePath, buffer, "binary");
    console.log("Invoking command:", `xattr -cr "${patchedFilePath}"`);
    await util_1.promisify(child_process_1.exec)(`xattr -cr "${patchedFilePath}"`);
    return patchedFilePath;
}
exports.patchFile = patchFile;
async function signFile(filePath) {
    console.log("Invoking command:", `codesign --force --deep --sign - "${filePath}"`);
    await util_1.promisify(child_process_1.exec)(`codesign --force --deep --sign - "${filePath}"`);
}
exports.signFile = signFile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaURBQXFDO0FBQ3JDLCtCQUFpQztBQUNqQywwQ0FBa0Q7QUFDbEQsK0JBQTJEO0FBQzNELHdEQUFnQztBQUNoQyx5Q0FBd0M7QUFFakMsS0FBSyxVQUFVLFNBQVMsQ0FBQyxRQUFnQjtJQUMvQyxNQUFNLGVBQWUsR0FBRyxjQUFPLENBQUMsY0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFLGVBQVEsQ0FBQyxRQUFRLEVBQUUsY0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsVUFBVSxHQUFHLGNBQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBRTNILElBQUksTUFBTSxHQUFHLE1BQU0sbUJBQVEsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFaEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5RUFBeUUsQ0FBQyxDQUFDO0lBQ3ZGLE1BQU0sR0FBRyxxQkFBVSxDQUNsQixNQUFNLEVBQ04saUJBQU8sQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLEVBQ3RDLGlCQUFPLENBQUMseUJBQXlCLENBQUMsT0FBTyxDQUN6QyxDQUFDO0lBRUYsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2RkFBNkYsQ0FBQyxDQUFDO0lBQzNHLE1BQU0sR0FBRyxxQkFBVSxDQUNsQixNQUFNLEVBQ04saUJBQU8sQ0FBQywrQkFBK0IsQ0FBQyxJQUFJLEVBQzVDLGlCQUFPLENBQUMsK0JBQStCLENBQUMsT0FBTyxDQUMvQyxDQUFDO0lBRUYsT0FBTyxDQUFDLEdBQUcsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sb0JBQVMsQ0FBQyxlQUFlLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRW5ELE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsY0FBYyxlQUFlLEdBQUcsQ0FBQyxDQUFDO0lBQ25FLE1BQU0sZ0JBQVMsQ0FBQyxvQkFBSSxDQUFDLENBQUMsY0FBYyxlQUFlLEdBQUcsQ0FBQyxDQUFDO0lBRXhELE9BQU8sZUFBZSxDQUFDO0FBQ3hCLENBQUM7QUExQkQsOEJBMEJDO0FBRU0sS0FBSyxVQUFVLFFBQVEsQ0FBQyxRQUFnQjtJQUM5QyxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLHFDQUFxQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0lBQ25GLE1BQU0sZ0JBQVMsQ0FBQyxvQkFBSSxDQUFDLENBQUMscUNBQXFDLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDekUsQ0FBQztBQUhELDRCQUdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYyB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tIFwidXRpbFwiO1xuaW1wb3J0IHsgcmVhZEZpbGUsIHdyaXRlRmlsZSB9IGZyb20gXCJmcy9wcm9taXNlc1wiO1xuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUsIGV4dG5hbWUsIHJlc29sdmUgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHJlZ2V4ZXMgZnJvbSBcIi4vcmVnZXhlc1wiO1xuaW1wb3J0IHsgcmVwbGFjZUFsbCB9IGZyb20gXCIuL3JvdXRpbmVzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXRjaEZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG5cdGNvbnN0IHBhdGNoZWRGaWxlUGF0aCA9IHJlc29sdmUoZGlybmFtZShmaWxlUGF0aCksIGJhc2VuYW1lKGZpbGVQYXRoLCBleHRuYW1lKGZpbGVQYXRoKSkgKyBcIi5wYXRjaGVkXCIgKyBleHRuYW1lKGZpbGVQYXRoKSk7XG5cblx0bGV0IGJ1ZmZlciA9IGF3YWl0IHJlYWRGaWxlKGZpbGVQYXRoLCBcImJpbmFyeVwiKTtcblxuXHRjb25zb2xlLmxvZyhcIlNlYXJjaGluZyBhbmQgcmVwbGFjaW5nIGZvciBpbnN0cnVjdGlvbiBfX21rbF9pbnRlbF9zZXJ2aW5nX2NwdV90cnVlLi4uXCIpO1xuXHRidWZmZXIgPSByZXBsYWNlQWxsKFxuXHRcdGJ1ZmZlcixcblx0XHRyZWdleGVzLl9fbWtsX3NlcnZfaW50ZWxfY3B1X3RydWUuZmluZCxcblx0XHRyZWdleGVzLl9fbWtsX3NlcnZfaW50ZWxfY3B1X3RydWUucmVwbGFjZVxuXHQpO1xuXG5cdGNvbnNvbGUubG9nKFwiU2VhcmNoaW5nIGFuZCByZXBsYWNpbmcgZm9yIGluc3RydWN0aW9ucyBfX2ludGVsX2Zhc3RfbWVtc2V0LkEgYW5kIF9faW50ZWxfZmFzdF9tZW1jcHkuQS4uLlwiKTtcblx0YnVmZmVyID0gcmVwbGFjZUFsbChcblx0XHRidWZmZXIsXG5cdFx0cmVnZXhlcy5fX2ludGVsX2Zhc3RfbWVtc2V0X29yX21lbWNweV9BLmZpbmQsXG5cdFx0cmVnZXhlcy5fX2ludGVsX2Zhc3RfbWVtc2V0X29yX21lbWNweV9BLnJlcGxhY2Vcblx0KTtcblxuXHRjb25zb2xlLmxvZyhcIldyaXRpbmcgcmVzdWx0aW5nIGZpbGUuLi5cIik7XG5cdGF3YWl0IHdyaXRlRmlsZShwYXRjaGVkRmlsZVBhdGgsIGJ1ZmZlciwgXCJiaW5hcnlcIik7XG5cblx0Y29uc29sZS5sb2coXCJJbnZva2luZyBjb21tYW5kOlwiLCBgeGF0dHIgLWNyIFwiJHtwYXRjaGVkRmlsZVBhdGh9XCJgKTtcblx0YXdhaXQgcHJvbWlzaWZ5KGV4ZWMpKGB4YXR0ciAtY3IgXCIke3BhdGNoZWRGaWxlUGF0aH1cImApO1xuXG5cdHJldHVybiBwYXRjaGVkRmlsZVBhdGg7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduRmlsZShmaWxlUGF0aDogc3RyaW5nKXtcblx0Y29uc29sZS5sb2coXCJJbnZva2luZyBjb21tYW5kOlwiLCBgY29kZXNpZ24gLS1mb3JjZSAtLWRlZXAgLS1zaWduIC0gXCIke2ZpbGVQYXRofVwiYCk7XG5cdGF3YWl0IHByb21pc2lmeShleGVjKShgY29kZXNpZ24gLS1mb3JjZSAtLWRlZXAgLS1zaWduIC0gXCIke2ZpbGVQYXRofVwiYCk7XG59XG4iXX0=